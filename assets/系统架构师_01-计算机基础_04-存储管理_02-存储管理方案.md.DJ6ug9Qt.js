import{_ as o,D as B,c as r,j as s,a as E,I as A,w as t,a7 as e,o as _}from"./chunks/framework.CdooE4P4.js";const c="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88.png",n="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86.png",i="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.png",l="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861.png",p="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E6%AE%B5%E6%B0%8F%E7%AE%A1%E7%90%86.png",d="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png",h="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8.png",x=JSON.parse('{"title":"存储管理方案","description":"","frontmatter":{"title":"存储管理方案","date":"2024-08-20T00:00:00.000Z"},"headers":[],"relativePath":"系统架构师/01-计算机基础/04-存储管理/02-存储管理方案.md","filePath":"系统架构师/01-计算机基础/04-存储管理/02-存储管理方案.md","lastUpdated":1724246094000}'),m={name:"系统架构师/01-计算机基础/04-存储管理/02-存储管理方案.md"},f=e('<h1 id="存储管理方案" tabindex="-1">存储管理方案 <a class="header-anchor" href="#存储管理方案" aria-label="Permalink to &quot;存储管理方案&quot;">​</a></h1><p>存储管理的主要目的是解决多个用户使用主存的问题。</p><p><img src="'+c+'" alt=""></p><h2 id="分区管理" tabindex="-1">分区管理 <a class="header-anchor" href="#分区管理" aria-label="Permalink to &quot;分区管理&quot;">​</a></h2><p>把主存的用户区划分成若干个区域，每个区域分配给一个用户作业使用，并限定它们只能在自己的区域中运行。</p><p><img src="'+n+'" alt=""></p><h2 id="分页管理" tabindex="-1">分页管理 <a class="header-anchor" href="#分页管理" aria-label="Permalink to &quot;分页管理&quot;">​</a></h2><h3 id="分页存储管理" tabindex="-1">分页存储管理 <a class="header-anchor" href="#分页存储管理" aria-label="Permalink to &quot;分页存储管理&quot;">​</a></h3>',8),u=e('<p><img src="'+i+'" alt=""></p><p><img src="'+l+'" alt=""></p><h2 id="段氏管理" tabindex="-1">段氏管理 <a class="header-anchor" href="#段氏管理" aria-label="Permalink to &quot;段氏管理&quot;">​</a></h2><p>分段式存储管理系统中，为每个片段分配一个连续的分区，而进程中的各个段可以离散的分配到主存的不同分区中。在系统中每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，在其中记录了该段在主存中的起始地址（又称为“基址”）和段的长度。进程在执行时，通过查段表来找到每个段所对应的主存区。</p><p><img src="'+p+'" alt=""></p><h2 id="段页式管理" tabindex="-1">段页式管理 <a class="header-anchor" href="#段页式管理" aria-label="Permalink to &quot;段页式管理&quot;">​</a></h2><p>段页式系统的基本原理是先将整个主存划分成大小相等的存储块（页框）， 将用户程序按程序的逻辑关系分为若干个段，再将每个段划分成若干页，以页框为单位离散分配。在段页式系统中，其地址结构由段号、段内页号和页内地址三部分组成。</p><p><img src="'+d+'" alt=""></p><h2 id="虚拟存储" tabindex="-1">虚拟存储 <a class="header-anchor" href="#虚拟存储" aria-label="Permalink to &quot;虚拟存储&quot;">​</a></h2><p>在前面介绍的存储管理方案中，必须为每个作业分配足够的空间，以便装入全部信息。当主存空间不能满足作业要求时，作业无法装入主存执行。如果一个作业只部分装入主存便可开始启动运行，其余部分暂时留在磁盘上，在需要时再装入主存，这样可以有效的利用主存空间。从用户角度看，该系统所具有的主存容量将比实际主存容量大得多，人们把这样的存储器称为虚拟存储器。</p><p><img src="'+h+'" alt=""></p>',11);function F(g,C,D,b,q,T){const a=B("font");return _(),r("div",null,[f,s("p",null,[E("将一个进程的地址空间划分成若干个大小相等的区域，称为"),A(a,{color:"#ff0000"},{default:t(()=>[E("页")]),_:1}),E("。相应的，将主存空间划分成与若干个物理块，称为"),A(a,{color:"#ff0000"},{default:t(()=>[E("块或页框")]),_:1}),E("。")]),u])}const k=o(m,[["render",F]]);export{x as __pageData,k as default};
