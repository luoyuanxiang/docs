import{_ as a,c as l,o,aa as i}from"./chunks/framework.C_F-uqbg.js";const t="/docs/%E5%82%A8%E5%AD%98%E5%B1%82%E6%AC%A1.png",s="/docs/%E4%B8%93%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8.png",e="/docs/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB-%E7%89%A9%E7%90%86%E8%B7%9D%E7%A6%BB.png",r="/docs/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8-1.png",n="/docs/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8-2.png",c="/docs/RAID0.png",d="/docs/RAID1.png",A="/docs/RAID3.png",_="/docs/RAID5.png",D="/docs/RAID6.png",I="/docs/RAID10.png",P=JSON.parse('{"title":"储存系统","description":"","frontmatter":{},"headers":[],"relativePath":"md/系统架构师/计算机基础/3.储存系统.md","filePath":"md/系统架构师/计算机基础/3.储存系统.md","lastUpdated":1723723703000}'),R={name:"md/系统架构师/计算机基础/3.储存系统.md"},h=i('<h1 id="储存系统" tabindex="-1">储存系统 <a class="header-anchor" href="#储存系统" aria-label="Permalink to &quot;储存系统&quot;">​</a></h1><h2 id="储存的层次" tabindex="-1">储存的层次 <a class="header-anchor" href="#储存的层次" aria-label="Permalink to &quot;储存的层次&quot;">​</a></h2><p><img src="'+t+'" alt="储存层次" loading="lazy"></p><h2 id="储存器" tabindex="-1">储存器 <a class="header-anchor" href="#储存器" aria-label="Permalink to &quot;储存器&quot;">​</a></h2><h3 id="专用处理器" tabindex="-1">专用处理器 <a class="header-anchor" href="#专用处理器" aria-label="Permalink to &quot;专用处理器&quot;">​</a></h3><p><img src="'+s+'" alt="专用处理器" loading="lazy"></p><h3 id="存储器的分类" tabindex="-1">存储器的分类 <a class="header-anchor" href="#存储器的分类" aria-label="Permalink to &quot;存储器的分类&quot;">​</a></h3><ol><li>按照存储器的硬件结构：SRAM、DRAM、NVRAM、Flash、EPROM、Disk等</li><li>按照与处理器的物理距离划分 <img src="'+e+'" alt="存储器分类-物理距离" loading="lazy">]</li></ol><h2 id="主存储器" tabindex="-1">主存储器 <a class="header-anchor" href="#主存储器" aria-label="Permalink to &quot;主存储器&quot;">​</a></h2><ol><li>主存用来存放计算机运行期间所需要的程序和数据，CUP可直接随机地进行读/写。 <img src="'+r+'" alt="主存储器-1" loading="lazy"><img src="'+n+'" alt="主存储器-2" loading="lazy"></li></ol><h2 id="磁盘阵列" tabindex="-1">磁盘阵列 <a class="header-anchor" href="#磁盘阵列" aria-label="Permalink to &quot;磁盘阵列&quot;">​</a></h2><p>磁盘阵列是有多台磁盘存储器组成的一个快速、大容量、高可靠的外存子系统。现在常见的磁盘阵列称为廉价冗余磁盘阵列（Redundant Array of Independent Disk, RAID）.</p><ul><li>RAID 机制中共分8个级别，RAID 应用的主要技术有分块技术、交叉技术和重聚技术。 <ol><li>RAID 0级（无冗余和无校验的数据分块）：具有最高的I/O性能和最高的磁盘空间利用率，易管理，但系统的故障率高，属于非冗余系统，主要用于哪些关注性能、容量和价格而不是可靠性的系统。 <img src="'+c+'" alt="RAID 0级" loading="lazy"></li><li>RAID 1级（磁盘镜像阵列）：由磁盘对组成，每一个工作盘都有其对应的镜像盘，上面保存着与工作盘完全相同的数据拷贝，具有最高的安全性，但磁盘空间利用率只有50%。RAID 1主要用于存放系统软件、数据以及其他重要文件。它提供了数据的实时备份，一旦发生故障，所有的关键数据即刻就可使用。 <img src="'+d+'" alt="RAID 1级" loading="lazy"></li><li>RAID 2级（采用纠错海明码的磁盘阵列）：采用了海明码纠错技术，对数据的访问涉及阵列中的每一个盘。大量数据传输时I/O性能高，但不利于小批量数据传输。实际应用中很少使用。</li><li>RAID 3和RAID 4级（采用奇偶校验的磁盘阵列）：把奇偶校验码存放在一个独立的校验盘上。如果有一个盘失效，其上的数据可以通过其他盘上的数据进行异或运算得到。读取数据很快，但因为写入数据时要计算校验位，速度较慢。RAID 3采用位交叉奇偶校验码，RAID 4采用块交叉奇偶校验码。RAID 3适用于大型文件且I/O需求不频繁的应用，RAID 4适用于大型文件的读取。 <img src="'+A+'" alt="RAID 3级" loading="lazy"></li><li>RAID 5级（无独立校验盘的奇偶校验码磁盘阵列）：没有独立的校验盘，校验信息分布在组内所有盘上，对于大批量和小批量数据的读写性能都很好。使用了独立存取技术，阵列中每一个磁盘都相互独立操作，所以I/O请求可以并行处理。因此，该技术非常适合于I/O需求频繁的应用而不太适合于要求高数据传输率（大型文件）的应用，列如银行、金融、股市等大型数据处理中心的 OLTP 应用。当有N块阵列盘时，用户空间为N-1块盘容量。 <img src="'+_+'" alt="RAID 5级" loading="lazy"></li><li>RAID 6级（具有独立的数据硬盘与两个独立的分布式校验方案）：在RAID 6级的阵列中设置了一个专用的、可快速访问的异步校验盘。该盘具有独立的数据访问通路，但其性能改进有限，价格却很昂贵。 <img src="'+D+'" alt="RAID 6级" loading="lazy"></li><li>RAID 7级（具有最优化的异步高I/O速率和高数据传输的磁盘阵列）：是对 RAID 6的改进。在这种阵列中的所有磁盘，都具有较高的传输速度，有着优异的性能，是目前最高档次的磁盘阵列。</li><li>RAID 10级（高可靠性与高性能的组合）：由多个 RAID 等级组合而成，建立在 RAID 0和RAID 1基础上。RAID 1是一个冗余的备份阵列，而 RAID 0是负责数据读写的阵列，因此又称为 RAID 0+1。由于利用了 RAID 0极高的读写效率和 RAID 1较高的数据保护和恢复能力，是 RAID 10成为了一种性价比较高的等级。 <img src="'+I+'" alt="RAID 10级" loading="lazy"></li></ol></li></ul>',13),m=[h];function p(g,E,u,f,B,b){return o(),l("div",null,m)}const y=a(R,[["render",p]]);export{P as __pageData,y as default};
